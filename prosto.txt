const express = require('express');
const WebSocket = require('ws');
const path = require('path');

const app = express();
const PORT = 3000;

app.use(express.static(path.join(__dirname, 'public')));

const server = app.listen(PORT, () => {
  console.log(`Server running at http://localhost:${PORT}`);
});

const wss = new WebSocket.Server({ server });

const game = {
  players: {},
  deck: [],
  currentPlayer: null,
  phase: 'waiting',
  round: 0,
  dealSequence: [5, 5, 3, 3, 3, 3],
  currentDealIndex: 0,
  cardsToPlace: 0
};

function createDeck() {
  const suits = ['♠', '♥', '♦', '♣'];
  const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
  const deck = [];
  
  for (const suit of suits) {
    for (const rank of ranks) {
      deck.push({ suit, rank, id: `${rank}${suit}` });
    }
  }
  return shuffle(deck);
}

function shuffle(deck) {
  for (let i = deck.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }
  return deck;
}

function getCardValue(rank) {
  const values = { '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, '10':10, 'J':11, 'Q':12, 'K':13, 'A':14 };
  return values[rank];
}

wss.on('connection', (ws) => {
  console.log('New connection');

  ws.on('message', (message) => {
    const data = JSON.parse(message);
    
    switch (data.action) {
      case 'join':
        handleJoin(ws, data);
        break;
      case 'placeCard':
        handlePlaceCard(ws, data);
        break;
      case 'ready':
        handleReady(ws);
        break;
    }
  });

  ws.on('close', () => {
    console.log('Client disconnected');
    removePlayer(ws);
  });
});

function handleJoin(ws, data) {
  if (Object.keys(game.players).length >= 2) {
    ws.send(JSON.stringify({ type: 'error', message: 'Game is full' }));
    return;
  }

  const playerId = `player_${Date.now()}`;
  game.players[playerId] = {
    ws,
    name: data.name || `Player ${Object.keys(game.players).length + 1}`,
    hand: [],
    board: {
      top: Array(3).fill(null),
      middle: Array(5).fill(null),
      bottom: Array(5).fill(null)
    },
    ready: false
  };

  ws.send(JSON.stringify({
    type: 'joined',
    playerId,
    gameState: getPlayerGameState(playerId)
  }));

  broadcastLobbyStatus();
}

function handleReady(ws) {
  const player = findPlayerByWS(ws);
  if (player) {
    player.ready = true;
    broadcastLobbyStatus();
    
    if (Object.values(game.players).every(p => p.ready) && 
        Object.keys(game.players).length === 2) {
      startGame();
    }
  }
}

function startGame() {
  game.phase = 'dealing';
  game.deck = createDeck();
  game.round = 0;
  game.currentDealIndex = 0;
  dealCards();
}

function dealCards() {
  if (game.currentDealIndex >= game.dealSequence.length) {
    game.phase = 'scoring';
    calculateScores();
    broadcastGameState();
    setTimeout(resetGame, 5000);
    return;
  }

  game.cardsToPlace = game.dealSequence[game.currentDealIndex];
  const playerId = Object.keys(game.players)[game.round % 2];
  
  game.players[playerId].hand = game.deck.splice(0, game.cardsToPlace);
  game.currentPlayer = playerId;
  game.phase = 'placing';
  
  broadcastGameState();
  game.currentDealIndex++;
}

function handlePlaceCard(ws, data) {
  const player = findPlayerByWS(ws);
  if (!player || game.phase !== 'placing' || game.currentPlayer !== player.id) return;

  const { cardId, row, position } = data;
  const cardIndex = player.hand.findIndex(c => c.id === cardId);
  
  if (cardIndex === -1 || player.board[row][position] !== null) return;

  player.board[row][position] = player.hand[cardIndex];
  player.hand.splice(cardIndex, 1);
  game.cardsToPlace--;

  if (game.cardsToPlace === 0) {
    game.round++;
    dealCards();
  } else {
    broadcastGameState();
  }
}

function calculateScores() {
  Object.values(game.players).forEach(player => {
    player.score = evaluateBoard(player.board);
    player.combinations = checkCombinations(player.board);
  });
}

function evaluateBoard(board) {
  let score = 0;
  const errors = validateRowOrder(board);
  if (errors.length > 0) return 0;

  // Top: Set of 3
  if (board.top.every(c => c !== null)) {
    const ranks = board.top.map(c => c.rank);
    if (new Set(ranks).size === 1) score += 10;
  }

  // Middle: Straight/Flush
  if (board.middle.every(c => c !== null)) {
    const values = board.middle.map(c => getCardValue(c.rank)).sort((a,b) => a-b);
    const suits = board.middle.map(c => c.suit);
    if (isFlush(suits)) score += 20;
    if (isStraight(values)) score += 20;
  }

  // Bottom: Strong hand
  if (board.bottom.every(c => c !== null)) {
    const values = board.bottom.map(c => getCardValue(c.rank)).sort((a,b) => a-b);
    const suits = board.bottom.map(c => c.suit);
    if (isFlush(suits) && isStraight(values)) score += 30;
  }

  return score;
}

function validateRowOrder(board) {
  const errors = [];
  const topStr = Math.max(...board.top.map(c => c ? getCardValue(c.rank) : 0));
  const midStr = Math.max(...board.middle.map(c => c ? getCardValue(c.rank) : 0));
  const botStr = Math.max(...board.bottom.map(c => c ? getCardValue(c.rank) : 0));

  if (botStr > 0 && midStr > 0 && botStr <= midStr) {
    errors.push({ row: 'bottom', message: 'Bottom must be stronger than middle' });
  }
  if (midStr > 0 && topStr > 0 && midStr <= topStr) {
    errors.push({ row: 'middle', message: 'Middle must be stronger than top' });
  }

  return errors;
}

function checkCombinations(board) {
  const results = { top: null, middle: null, bottom: null };
  
  if (board.top.every(c => c)) {
    const ranks = board.top.map(c => c.rank);
    if (new Set(ranks).size === 1) results.top = 'Set (3 of a kind)';
  }
  
  if (board.middle.every(c => c)) {
    const values = board.middle.map(c => getCardValue(c.rank)).sort((a,b) => a-b);
    const suits = board.middle.map(c => c.suit);
    if (isFlush(suits)) results.middle = 'Flush';
    if (isStraight(values)) results.middle = results.middle ? `${results.middle}+Straight` : 'Straight';
  }
  
  if (board.bottom.every(c => c)) {
    const values = board.bottom.map(c => getCardValue(c.rank)).sort((a,b) => a-b);
    const suits = board.bottom.map(c => c.suit);
    if (isFlush(suits) && isStraight(values)) results.bottom = 'Straight Flush';
  }
  
  return results;
}

function isFlush(suits) {
  return new Set(suits).size === 1;
}

function isStraight(values) {
  return values[values.length-1] - values[0] === values.length-1;
}

function resetGame() {
  Object.values(game.players).forEach(player => {
    player.hand = [];
    player.board = {
      top: Array(3).fill(null),
      middle: Array(5).fill(null),
      bottom: Array(5).fill(null)
    };
    player.score = null;
    player.ready = false;
  });

  game.phase = 'waiting';
  game.deck = [];
  game.currentPlayer = null;
  game.round = 0;
  game.currentDealIndex = 0;

  broadcastLobbyStatus();
}

function findPlayerByWS(ws) {
  const entry = Object.entries(game.players).find(([id, p]) => p.ws === ws);
  return entry ? { id: entry[0], ...entry[1] } : null;
}

function removePlayer(ws) {
  const playerId = Object.keys(game.players).find(id => game.players[id].ws === ws);
  if (playerId) {
    delete game.players[playerId];
    broadcastLobbyStatus();
  }
}

function broadcastLobbyStatus() {
  const lobbyState = {
    type: 'lobby',
    players: Object.values(game.players).map(p => ({ name: p.name, ready: p.ready })),
    canStart: Object.values(game.players).every(p => p.ready) && Object.keys(game.players).length === 2
  };

  broadcast(JSON.stringify(lobbyState));
}

function broadcastGameState() {
  Object.keys(game.players).forEach(playerId => {
    game.players[playerId].ws.send(JSON.stringify({
      type: 'gameState',
      ...getPlayerGameState(playerId)
    }));
  });
}

function getPlayerGameState(playerId) {
  const opponentId = Object.keys(game.players).find(id => id !== playerId);
  return {
    phase: game.phase,
    currentPlayer: game.currentPlayer,
    round: game.round,
    cardsToPlace: game.cardsToPlace,
    player: sanitizePlayerState(game.players[playerId], true),
    opponent: opponentId ? sanitizePlayerState(game.players[opponentId], false) : null,
    deckSize: game.deck.length
  };
}

function sanitizePlayerState(player, isSelf) {
  return {
    id: isSelf ? player.id : null,
    name: player.name,
    hand: isSelf ? player.hand : null,
    board: player.board,
    score: player.score,
    combinations: player.combinations,
    ready: isSelf ? player.ready : null
  };
}

function broadcast(message) {
  Object.values(game.players).forEach(player => {
    if (player.ws.readyState === WebSocket.OPEN) {
      player.ws.send(message);
    }
  });
}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pineapple OFC Poker</title>
  <style>
    :root {
      --card-width: 70px;
      --card-height: 100px;
      --red-suit: #e74c3c;
      --black-suit: #2c3e50;
      --primary: #27ae60;
      --secondary: #2ecc71;
      --dark-bg: #1a6b1a;
      --light-bg: #0d4d0d;
      --error: #e74c3c;
    }

    body {
      font-family: 'Arial', sans-serif;
      background-color: var(--dark-bg);
      color: white;
      line-height: 1.6;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    h1, h2 {
      text-align: center;
      margin-bottom: 15px;
    }

    /* Lobby styles */
    .lobby {
      background-color: var(--light-bg);
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
    }

    .player-list {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 15px 0;
    }

    .player-badge {
      background-color: rgba(255, 255, 255, 0.1);
      padding: 10px 15px;
      border-radius: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .player-badge.ready::after {
      content: '✓';
      color: var(--secondary);
    }

    /* Game area */
    .game-area {
      display: none;
    }

    .player-area {
      background-color: var(--light-bg);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      position: relative;
    }

    .board {
      margin: 15px 0;
    }

    .board-row {
      display: flex;
      justify-content: center;
      gap: 5px;
      margin-bottom: 25px;
      position: relative;
    }

    .board-slot {
      width: var(--card-width);
      height: var(--card-height);
      border: 2px dashed rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: all 0.2s;
    }

    .board-slot.highlight {
      background-color: rgba(255, 255, 0, 0.2);
      border-color: yellow;
      cursor: pointer;
    }

    /* Card styles */
    .card {
      width: var(--card-width);
      height: var(--card-height);
      background-color: white;
      border-radius: 5px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 5px;
      font-weight: bold;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      cursor: pointer;
      user-select: none;
    }

    .card.red {
      color: var(--red-suit);
    }

    .card.black {
      color: var(--black-suit);
    }

    .card.selected {
      transform: translateY(-10px);
      box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3);
    }

    .card-value {
      font-size: 1.2rem;
    }

    .card-suit {
      font-size: 1.5rem;
      text-align: center;
    }

    /* Hand area */
    .hand {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin: 20px 0;
      min-height: var(--card-height);
    }

    /* Status area */
    .status {
      text-align: center;
      padding: 10px;
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 5px;
      margin: 10px 0;
      font-weight: bold;
    }

    .score {
      font-size: 1.2rem;
      text-align: center;
      margin: 10px 0;
    }

    /* Combination indicators */
    .combo-indicator {
      position: absolute;
      bottom: -20px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 12px;
      font-weight: bold;
    }

    .combo-good {
      color: #2ecc71;
    }

    .combo-bad {
      color: var(--error);
    }

    /* Controls */
    .controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 20px;
    }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      background-color: var(--primary);
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }

    button:hover {
      background-color: var(--secondary);
    }

    button:disabled {
      background-color: #7f8c8d;
      cursor: not-allowed;
    }

    input {
      padding: 10px;
      border: none;
      border-radius: 5px;
      min-width: 200px;
    }

    /* Error messages */
    .error-message {
      color: var(--error);
      text-align: center;
      margin: 5px 0;
      font-weight: bold;
      animation: shake 0.5s;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }

    /* Responsive */
    @media (max-width: 768px) {
      :root {
        --card-width: 50px;
        --card-height: 75px;
      }

      .card-value {
        font-size: 0.9rem;
      }

      .card-suit {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Pineapple OFC Poker</h1>
    
    <!-- Lobby Section -->
    <div class="lobby" id="lobby">
      <h2>Game Lobby</h2>
      <div class="player-list" id="playerList">
        <!-- Players will appear here -->
      </div>
      <div class="controls">
        <input type="text" id="playerName" placeholder="Your name" maxlength="15">
        <button id="joinBtn">Join Game</button>
        <button id="readyBtn" disabled>Ready</button>
      </div>
    </div>
    
    <!-- Game Area (hidden initially) -->
    <div class="game-area" id="gameArea">
      <!-- Opponent Board -->
      <div class="player-area">
        <h2 id="opponentName">Opponent</h2>
        <div class="score" id="opponentScore"></div>
        <div class="board" id="opponentBoard">
          <div class="board-row" data-row="top">
            <div class="board-slot" data-pos="0"></div>
            <div class="board-slot" data-pos="1"></div>
            <div class="board-slot" data-pos="2"></div>
          </div>
          <div class="board-row" data-row="middle">
            <div class="board-slot" data-pos="0"></div>
            <div class="board-slot" data-pos="1"></div>
            <div class="board-slot" data-pos="2"></div>
            <div class="board-slot" data-pos="3"></div>
            <div class="board-slot" data-pos="4"></div>
          </div>
          <div class="board-row" data-row="bottom">
            <div class="board-slot" data-pos="0"></div>
            <div class="board-slot" data-pos="1"></div>
            <div class="board-slot" data-pos="2"></div>
            <div class="board-slot" data-pos="3"></div>
            <div class="board-slot" data-pos="4"></div>
          </div>
        </div>
      </div>
      
      <!-- Current Player Board -->
      <div class="player-area">
        <h2 id="playerNameDisplay">You</h2>
        <div class="score" id="playerScore"></div>
        <div class="board" id="playerBoard">
          <div class="board-row" data-row="top">
            <div class="board-slot" data-pos="0"></div>
            <div class="board-slot" data-pos="1"></div>
            <div class="board-slot" data-pos="2"></div>
          </div>
          <div class="board-row" data-row="middle">
            <div class="board-slot" data-pos="0"></div>
            <div class="board-slot" data-pos="1"></div>
            <div class="board-slot" data-pos="2"></div>
            <div class="board-slot" data-pos="3"></div>
            <div class="board-slot" data-pos="4"></div>
          </div>
          <div class="board-row" data-row="bottom">
            <div class="board-slot" data-pos="0"></div>
            <div class="board-slot" data-pos="1"></div>
            <div class="board-slot" data-pos="2"></div>
            <div class="board-slot" data-pos="3"></div>
            <div class="board-slot" data-pos="4"></div>
          </div>
        </div>
      </div>
      
      <!-- Current Player Hand -->
      <div class="player-area">
        <h2>Your Hand</h2>
        <div class="status" id="gameStatus">Waiting for opponent...</div>
        <div class="error-message" id="errorMessage"></div>
        <div class="hand" id="playerHand">
          <!-- Cards will appear here -->
        </div>
      </div>
    </div>
  </div>

  <script>
    // DOM Elements
    const lobbyEl = document.getElementById('lobby');
    const gameAreaEl = document.getElementById('gameArea');
    const playerListEl = document.getElementById('playerList');
    const joinBtn = document.getElementById('joinBtn');
    const readyBtn = document.getElementById('readyBtn');
    const playerNameInput = document.getElementById('playerName');
    const playerNameDisplay = document.getElementById('playerNameDisplay');
    const opponentNameEl = document.getElementById('opponentName');
    const playerScoreEl = document.getElementById('playerScore');
    const opponentScoreEl = document.getElementById('opponentScore');
    const gameStatusEl = document.getElementById('gameStatus');
    const errorMessageEl = document.getElementById('errorMessage');
    const playerHandEl = document.getElementById('playerHand');
    const playerBoardEl = document.getElementById('playerBoard');
    const opponentBoardEl = document.getElementById('opponentBoard');

    // Game state
    let playerId = null;
    let selectedCard = null;
    let ws = null;

    // Initialize WebSocket
    function connectWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const host = window.location.host;
      ws = new WebSocket(`${protocol}//${host}`);

      ws.onopen = () => {
        console.log('Connected to server');
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        console.log('Received:', data);
        handleMessage(data);
      };

      ws.onclose = () => {
        console.log('Disconnected from server');
        alert('Connection lost. Please refresh the page.');
      };
    }

    // Message handler
    function handleMessage(data) {
      switch (data.type) {
        case 'lobby':
          updateLobby(data);
          break;
        case 'joined':
          handleJoined(data);
          break;
        case 'gameState':
          updateGameState(data);
          break;
        case 'error':
          showError(data.message);
          break;
        case 'orderError':
          showOrderError(data.errors);
          break;
      }
    }

    // Lobby functions
    function updateLobby(data) {
      playerListEl.innerHTML = '';
      data.players.forEach(player => {
        const playerEl = document.createElement('div');
        playerEl.className = `player-badge ${player.ready ? 'ready' : ''}`;
        playerEl.textContent = player.name;
        playerListEl.appendChild(playerEl);
      });

      readyBtn.disabled = !playerId || data.players.length < 1;
    }

    function handleJoined(data) {
      playerId = data.playerId;
      playerNameDisplay.textContent = playerNameInput.value || 'You';
      joinBtn.disabled = true;
      readyBtn.disabled = false;
    }

    // Game state functions
    function updateGameState(data) {
      // Show game area if we were in lobby
      if (data.phase !== 'waiting') {
        lobbyEl.style.display = 'none';
        gameAreaEl.style.display = 'block';
      }

      // Update player hand
      updatePlayerHand(data.player.hand);

      // Update boards
      updateBoard(data.player.board, playerBoardEl, true, data.player.combinations);
      if (data.opponent) {
        opponentNameEl.textContent = data.opponent.name || 'Opponent';
        updateBoard(data.opponent.board, opponentBoardEl, false, data.opponent.combinations);
        opponentScoreEl.textContent = data.opponent.score !== null ? `Score: ${data.opponent.score}` : '';
      }

      // Update scores
      playerScoreEl.textContent = data.player.score !== null ? `Score: ${data.player.score}` : '';

      // Update game status
      updateGameStatus(data);
    }

    function updatePlayerHand(hand) {
      playerHandEl.innerHTML = '';
      if (hand) {
        hand.forEach(card => {
          if (card) {
            const cardEl = createCardElement(card);
            playerHandEl.appendChild(cardEl);
          }
        });
      }
    }

    function updateBoard(board, boardEl, isInteractive, combinations) {
      for (const row of ['top', 'middle', 'bottom']) {
        const rowEl = boardEl.querySelector(`[data-row="${row}"]`);
        const slots = rowEl.querySelectorAll('.board-slot');
        
        // Clear existing combo indicators
        const existingCombo = rowEl.querySelector('.combo-indicator');
        if (existingCombo) rowEl.removeChild(existingCombo);

        // Add combo indicator if exists
        if (combinations && combinations[row]) {
          const comboEl = document.createElement('div');
          comboEl.className = 'combo-indicator combo-good';
          comboEl.textContent = combinations[row];
          rowEl.appendChild(comboEl);
        }

        // Update cards in slots
        board[row].forEach((card, index) => {
          const slot = slots[index];
          slot.innerHTML = '';
          
          if (card) {
            const cardEl = createCardElement(card);
            slot.appendChild(cardEl);
          }
          
          // Make slots interactive if it's player's turn
          if (isInteractive && 
              !card && 
              selectedCard !== null &&
              boardEl === playerBoardEl) {
            slot.classList.add('highlight');
            slot.onclick = () => placeCard(row, index);
          } else {
            slot.classList.remove('highlight');
            slot.onclick = null;
          }
        });
      }
    }

    function updateGameStatus(data) {
      let statusText = '';
      
      switch (data.phase) {
        case 'waiting':
          statusText = 'Waiting for players...';
          break;
        case 'dealing':
          statusText = 'Dealing cards...';
          break;
        case 'placing':
          statusText = `Place ${data.cardsToPlace} card(s) on your board`;
          break;
        case 'scoring':
          statusText = 'Game over! Calculating scores...';
          break;
      }
      
      gameStatusEl.textContent = statusText;
    }

    // Card functions
    function createCardElement(card) {
      if (!card) return null;
      
      const cardEl = document.createElement('div');
      cardEl.className = `card ${['♥', '♦'].includes(card.suit) ? 'red' : 'black'}`;
      cardEl.dataset.id = card.id;
      cardEl.innerHTML = `
        <div class="card-value">${card.rank}</div>
        <div class="card-suit">${card.suit}</div>
      `;
      
      cardEl.addEventListener('click', () => selectCard(cardEl, card.id));
      return cardEl;
    }

    function selectCard(cardEl, cardId) {
      // Deselect if same card
      if (selectedCard === cardId) {
        cardEl.classList.remove('selected');
        selectedCard = null;
        clearHighlights();
        return;
      }
      
      // Deselect previous
      if (selectedCard) {
        const prevCard = playerHandEl.querySelector(`.card[data-id="${selectedCard}"]`);
        if (prevCard) prevCard.classList.remove('selected');
      }
      
      // Select new
      cardEl.classList.add('selected');
      selectedCard = cardId;
      highlightValidSlots();
    }

    function highlightValidSlots() {
      clearHighlights();
      
      const slots = playerBoardEl.querySelectorAll('.board-slot:empty');
      slots.forEach(slot => {
        slot.classList.add('highlight');
        const row = slot.closest('.board-row').dataset.row;
        const pos = parseInt(slot.dataset.pos);
        slot.onclick = () => placeCard(row, pos);
      });
    }

    function clearHighlights() {
      const slots = playerBoardEl.querySelectorAll('.board-slot');
      slots.forEach(slot => {
        slot.classList.remove('highlight');
        slot.onclick = null;
      });
    }

    function placeCard(row, position) {
      if (!selectedCard) return;
      
      ws.send(JSON.stringify({
        action: 'placeCard',
        cardId: selectedCard,
        row,
        position
      }));
      
      selectedCard = null;
      clearHighlights();
    }

    // Error handling
    function showError(message) {
      errorMessageEl.textContent = message;
      setTimeout(() => errorMessageEl.textContent = '', 3000);
    }

    function showOrderError(errors) {
      // Clear previous errors
      document.querySelectorAll('.combo-bad').forEach(el => el.classList.remove('combo-bad'));
      
      errors.forEach(error => {
        const rowEl = playerBoardEl.querySelector(`[data-row="${error.row}"]`);
        const comboEl = rowEl.querySelector('.combo-indicator') || document.createElement('div');
        comboEl.className = 'combo-indicator combo-bad';
        comboEl.textContent = error.message;
        rowEl.appendChild(comboEl);
      });
    }

    // Event listeners
    joinBtn.addEventListener('click', () => {
      const name = playerNameInput.value.trim() || `Player${Math.floor(Math.random() * 1000)}`;
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        connectWebSocket();
      }
      
      ws.send(JSON.stringify({
        action: 'join',
        name
      }));
    });

    readyBtn.addEventListener('click', () => {
      ws.send(JSON.stringify({
        action: 'ready'
      }));
      readyBtn.disabled = true;
    });

    // Initialize
    connectWebSocket();
  </script>
</body>
</html>
some text
